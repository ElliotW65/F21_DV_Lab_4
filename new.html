<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Lab 4</title>

        <script src='https://d3js.org/d3.v7.min.js'></script>

        <style>
            body { margin: 0; padding: 0; }
            #map { position: absolute; top: 0; bottom: 0; height: 100%; width: 100%; }
            #pop-up {width: 50%; height: 50%; position: absolute;}
            #pop-up-bar-chart {width: 90%; height: 90%; margin: auto;}
            #arcG {position: absolute; top: 10%; left: 25%;}
            .pie-year { font-family: Open Sans, sans-serif;
                        font-size: 30px;
                        font-weight: 700;
                        opacity: 0.5;}

        </style>

    <body>
        <div id="pop-up">
            <div id="pop-up-bar-chart"></div>
        </div>

        <script> 

            var link = "https://api.mapbox.com/geocoding/v5/mapbox.places/United%20Kingdom.json?access_token=pk.eyJ1IjoiZWxsaW90dzY1IiwiYSI6ImNrbGk0amV4MTA5bHUycW5tN2JzM3J0bTIifQ.OGT4ltSNZ7vyd_yEUg8afQ"

            function urlFormat(e) {
                //var coords = [e.lngLat.lng, e.lngLat.lat]

                return e;
            }

            function urlBuilder(country) {
                    var countryFormat = urlFormat(country);
                    var urlPrefix = "https://api.mapbox.com/geocoding/v5/mapbox.places/";
                    var accessToken = ".json?access_token=pk.eyJ1IjoiZWxsaW90dzY1IiwiYSI6ImNrbGk0amV4MTA5bHUycW5tN2JzM3J0bTIifQ.OGT4ltSNZ7vyd_yEUg8afQ";
                    return urlPrefix + countryFormat[0] + "," + countryFormat[1] + accessToken;
            }

            function httpGetAsync(country, callback) {
                var URL = urlBuilder(country);
                var xmlHttp = new XMLHttpRequest();
                xmlHttp.onreadystatechange = function() { 
                    if (xmlHttp.readyState == 4 && xmlHttp.status == 200)
                        callback(xmlHttp.responseText, country);
                }
                xmlHttp.open("GET", URL, true); // true for asynchronous 
                xmlHttp.send(null);
            }


            function returnCenter(data) {
                
                const info = JSON.parse(data);

                for(i of info.features) {
                    if(i.place_type[0] == "country") {
                        var country = i.place_name;
                    }
                }

                console.log(country);
            }

            var svg = d3.select('body').append('svg')
                        .attr('width', '600px')
                        .attr('height', '600px')

            var g = svg.append("g")
                        .attr('transform', 'translate(' + 600/2 +  ',' + 600/2 +')');

            d3.csv('bp data.csv').then(function(data) {

                console.log(data);

                function groupByCountry(data) {
                    const newGroups = data.reduce(function(groups, item) {
                    const group = (groups[item.Country] || []);
                    group.push(item);
                    groups[item.Country] = group;
                    return groups;
                    }, {});

                    return newGroups;
                }

                function groupByYear(data) {
                    const newGroups = data.reduce(function(groups, item) {
                    const group = (groups[item.Year] || []);
                    group.push(item);
                    groups[item.Year] = group;
                    return groups;
                    }, {});

                    return newGroups;
                }

                var data = groupByCountry(data);

                var displayData = data["Algeria"];

                console.log(displayData);

                var year = 1965;

                var top_n = 12;

                displayData.forEach(d => {
                    d.Value = +d.Value,
                    d.lastValue = +d.lastValue,
                    d.Value = isNaN(d.Value) ? 0 : d.Value,
                    d.Year = +d.Year,
                    d.colour = d3.hsl(Math.random()*360,0.75,0.75)
                });

                yearSlice = displayData.filter(d => d.Year == year && !isNaN(d.Value))
                        .sort((a,b) => b.Value - a.Value)
                        .slice(0,top_n);

                var yearText = g.append("text")
                        .classed("pie-year", true)
                        .attr("text-anchor", "middle")
                        .attr('transform', 'translate(' + 0 +  ',' + 10 +')')
                        .text(year);



                // Set colour scheme of pie chart
                var pieColor = d3.scaleOrdinal().range(d3.schemeSet3);

                var radius = Math.min(300, 300/ 2);

                // Function to update the pie chart
                function updatePie(data) {

                    var pie = d3.pie().value(function(d) {
                            return d.Value; 
                        });

                    var arc = d3.arc()
                        .innerRadius(radius - 100)
                        .outerRadius(radius - 50);

                    var path = g.selectAll("path")
                    .data(pie(data))

                    yearText.text(year);

                    console.log(pie(data));

                    var enterPath = path.enter().append('g').classed("arcG", true).append("path")
                        .transition()
                        .duration(500)
                        .attr("fill", function(d, i) { return pieColor(i); })
                        .attr("d", arc)
                        .attrTween("d", function (d) {
                            var i = d3.interpolate(d.endAngle, d.startAngle);
                            return function (t) {
                            d.startAngle = i(t);
                            return arc(d);
                        }
                        });

                    var updatePath = path.attr("d", arc)
                        .transition()
                        .duration(1000)
                        .attrTween("d", tweenFunction)

                    // Function to smoothly update the segments of the pie chart when new data is used 
                    function tweenFunction(newAngle) {
                        var inter = d3.interpolate(this.currentAngle, newAngle);
                        this.currentAngle = inter(0);
                        return function(t) {
                            return arc(inter(t)); 
                        };
                    }
                };

                let animatPie = d3.interval(function() {

                    yearSlice = displayData.filter(d => d.Year == year && !isNaN(d.Value))
                        .sort((a,b) => b.Value - a.Value)
                        .slice(0,top_n);

                    updatePie(yearSlice);

                    if(year == 2020) {animatPie.stop()}

                    year += 1;
                }, 1000);

            });


        </script>

    </head>